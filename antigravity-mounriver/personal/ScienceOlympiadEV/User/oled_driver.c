#include "oled_driver.h"

// Simple 5x7 ASCII Font (Space through Z roughly)
// You can expand this array for full ASCII if needed.
const uint8_t FONT5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // Space
    {0x00, 0x00, 0x5F, 0x00, 0x00}, // !
    {0x00, 0x07, 0x00, 0x07, 0x00}, // "
    {0x14, 0x7F, 0x14, 0x7F, 0x14}, // #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // $
    {0x23, 0x13, 0x08, 0x64, 0x62}, // %
    {0x36, 0x49, 0x55, 0x22, 0x50}, // &
    {0x00, 0x05, 0x03, 0x00, 0x00}, // '
    {0x00, 0x1C, 0x22, 0x41, 0x00}, // (
    {0x00, 0x41, 0x22, 0x1C, 0x00}, // )
    {0x14, 0x08, 0x3E, 0x08, 0x14}, // *
    {0x08, 0x08, 0x3E, 0x08, 0x08}, // +
    {0x00, 0x50, 0x30, 0x00, 0x00}, // ,
    {0x08, 0x08, 0x08, 0x08, 0x08}, // -
    {0x00, 0x60, 0x60, 0x00, 0x00}, // .
    {0x20, 0x10, 0x08, 0x04, 0x02}, // /
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 0
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // 1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 2
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // 3
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // 4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 5
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 8
    {0x06, 0x49, 0x49, 0x29, 0x1E}, // 9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // :
    {0x00, 0x56, 0x36, 0x00, 0x00}, // ;
    {0x08, 0x14, 0x22, 0x41, 0x00}, // <
    {0x14, 0x14, 0x14, 0x14, 0x14}, // =
    {0x00, 0x41, 0x22, 0x14, 0x08}, // >
    {0x02, 0x01, 0x51, 0x09, 0x06}, // ?
    {0x32, 0x49, 0x79, 0x41, 0x3E}, // @
    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // A
    {0x7F, 0x49, 0x49, 0x49, 0x36}, // B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // C
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // D
    {0x7F, 0x49, 0x49, 0x49, 0x41}, // E
    {0x7F, 0x09, 0x09, 0x09, 0x01}, // F
    {0x3E, 0x41, 0x49, 0x49, 0x7A}, // G
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // H
    {0x00, 0x41, 0x7F, 0x41, 0x00}, // I
    {0x20, 0x40, 0x41, 0x3F, 0x01}, // J
    {0x7F, 0x08, 0x14, 0x22, 0x41}, // K
    {0x7F, 0x40, 0x40, 0x40, 0x40}, // L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // M
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, // N
    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // O
    {0x7F, 0x09, 0x09, 0x09, 0x06}, // P
    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // Q
    {0x7F, 0x09, 0x19, 0x29, 0x46}, // R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // S
    {0x01, 0x01, 0x7F, 0x01, 0x01}, // T
    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // U
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, // V
    {0x3F, 0x40, 0x38, 0x40, 0x3F}, // W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // X
    {0x07, 0x08, 0x70, 0x08, 0x07}, // Y
    {0x61, 0x51, 0x49, 0x45, 0x43}, // Z
};

// --- Bit-Bang I2C Helpers ---

// Tiny delay loop
void I2C_Delay(void) {
  volatile uint8_t i = 10;
  while (i--)
    ;
}

void I2C_Start(void) {
  GPIOB_SetBits(I2C_SDA_PIN);
  GPIOB_SetBits(I2C_SCL_PIN);
  I2C_Delay();
  GPIOB_ResetBits(I2C_SDA_PIN);
  I2C_Delay();
  GPIOB_ResetBits(I2C_SCL_PIN);
}

void I2C_Stop(void) {
  GPIOB_ResetBits(I2C_SDA_PIN);
  GPIOB_SetBits(I2C_SCL_PIN);
  I2C_Delay();
  GPIOB_SetBits(I2C_SDA_PIN);
  I2C_Delay();
}

void I2C_SendByte(uint8_t byte) {
  uint8_t i;
  for (i = 0; i < 8; i++) {
    if (byte & 0x80)
      GPIOB_SetBits(I2C_SDA_PIN);
    else
      GPIOB_ResetBits(I2C_SDA_PIN);

    byte <<= 1;
    I2C_Delay();
    GPIOB_SetBits(I2C_SCL_PIN);
    I2C_Delay();
    GPIOB_ResetBits(I2C_SCL_PIN);
  }

  // Ack cycle (we just ignore the ack bit)
  GPIOB_SetBits(I2C_SDA_PIN); // Release line
  I2C_Delay();
  GPIOB_SetBits(I2C_SCL_PIN);
  I2C_Delay();
  GPIOB_ResetBits(I2C_SCL_PIN);
}

void OLED_WriteCmd(uint8_t cmd) {
  I2C_Start();
  I2C_SendByte(0x78); // Address
  I2C_SendByte(0x00); // Command Mode
  I2C_SendByte(cmd);
  I2C_Stop();
}

void OLED_WriteData(uint8_t data) {
  I2C_Start();
  I2C_SendByte(0x78); // Address
  I2C_SendByte(0x40); // Data Mode
  I2C_SendByte(data);
  I2C_Stop();
}

// --- Display Functions ---

void OLED_Init(void) {
  GPIOB_ModeCfg(I2C_SDA_PIN | I2C_SCL_PIN, GPIO_ModeOut_PP_5mA);
  GPIOB_SetBits(I2C_SDA_PIN | I2C_SCL_PIN); // Idle High

  // 3. SSD1306 Initialization Commands
  OLED_WriteCmd(0xAE); // Display Off
  OLED_WriteCmd(0x20); // Set Memory Addressing Mode
  OLED_WriteCmd(0x00); // 00 = Horizontal Addressing Mode (Good for text)
  OLED_WriteCmd(0xC8); // Set COM Output Scan Direction
  OLED_WriteCmd(0x00); // Set Low Column Address
  OLED_WriteCmd(0x10); // Set High Column Address
  OLED_WriteCmd(0x40); // Set Start Line
  OLED_WriteCmd(0x81); // Contrast Control
  OLED_WriteCmd(0xFF);
  OLED_WriteCmd(0xA1); // Set Segment Re-map
  OLED_WriteCmd(0xA6); // Normal Display
  OLED_WriteCmd(0xA8); // Multiplex Ratio
  OLED_WriteCmd(0x1F); // 32 rows -> 31
  OLED_WriteCmd(0xD3); // Display Offset
  OLED_WriteCmd(0x00);
  OLED_WriteCmd(0xD5); // Display Clock Divide
  OLED_WriteCmd(0xF0);
  OLED_WriteCmd(0xD9); // Pre-charge Period
  OLED_WriteCmd(0x22);
  OLED_WriteCmd(0xDA); // COM Pins Config
  OLED_WriteCmd(0x02);
  OLED_WriteCmd(0xDB); // VCOMH Deselect Level
  OLED_WriteCmd(0x20);
  OLED_WriteCmd(0x8D); // Charge Pump
  OLED_WriteCmd(0x14); // Enable
  OLED_WriteCmd(0xAF); // Display ON

  OLED_Clear();
}

// Sets cursor to a specific page (row 0-3) and column (0-127)
void OLED_SetCursor(uint8_t page, uint8_t col) {
  OLED_WriteCmd(0xB0 + page);
  OLED_WriteCmd(0x00 | (col & 0x0F));
  OLED_WriteCmd(0x10 | ((col >> 4) & 0x0F));
}

void OLED_Clear(void) {
  uint8_t i, n;
  for (i = 0; i < 4; i++) {  // 4 Pages (32 rows / 8)
    OLED_WriteCmd(0xB0 + i); // Set Page
    OLED_WriteCmd(0x00);     // Set Lower Column Start
    OLED_WriteCmd(0x10);     // Set Higher Column Start
    for (n = 0; n < 128; n++) {
      OLED_WriteData(0x00);
    }
  }
}

// Show a single character
void OLED_ShowChar(uint8_t x, uint8_t y, char chr) {
  uint8_t i;

  // Auto-convert lowercase to uppercase since Font is only Uppercase
  if (chr >= 'a' && chr <= 'z') {
    chr -= 32;
  }

  // Offset for ASCII (Space is 32, our array starts at 0)
  uint8_t char_index = chr - ' ';

  if (x > 120) {
    x = 0;
    y++;
  } // Wrap if too wide

  OLED_SetCursor(y, x);

  // Bounds check: Font array has ~66 elements (Space to Z + extras)
  // 'Z' is index 58. ']' is 61. Array size is 66.
  if (char_index >= 66) {
    // Unknown char, print space
    for (i = 0; i < 6; i++)
      OLED_WriteData(0x00);
    return;
  }

  for (i = 0; i < 5; i++) {
    OLED_WriteData(FONT5x7[char_index][i]);
  }
  // Add 1 pixel spacing
  OLED_WriteData(0x00);
}

// Show a string
void OLED_ShowString(uint8_t x, uint8_t y, char *str) {
  while (*str) {
    OLED_ShowChar(x, y, *str);
    x += 6; // 5 width + 1 space
    str++;
  }
}