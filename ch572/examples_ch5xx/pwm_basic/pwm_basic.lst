
pwm_basic.elf:     file format elf32-littleriscv


Disassembly of section .init:

00000000 <InterruptVector>:
	void InterruptVector()         __attribute__((naked)) __attribute((section(".init"))) __attribute((weak,alias("InterruptVectorDefault"))) __attribute((naked));
	void InterruptVectorDefault()  __attribute__((naked)) __attribute((section(".init"))) __attribute((naked));
	void InterruptVectorDefault( void )
	{
		#if !defined(FUNCONF_TINYVECTOR) || !FUNCONF_TINYVECTOR
			asm volatile( DEFAULT_INTERRUPT_VECTOR_CONTENTS );
   0:	0c20006f          	j	c2 <handle_reset>
   4:	0000                	unimp
   6:	0000                	unimp
   8:	0160                	addi	s0,sp,140
   a:	0000                	unimp
   c:	0160                	addi	s0,sp,140
   e:	0000                	unimp
  10:	bda9                	j	fffffe6a <_eusrstack+0xdfff7e6a>
  12:	f3f9                	bnez	a5,ffffffd8 <_eusrstack+0xdfff7fd8>
  14:	0160                	addi	s0,sp,140
	...
  1e:	0000                	unimp
  20:	0160                	addi	s0,sp,140
  22:	0000                	unimp
  24:	0160                	addi	s0,sp,140
	...
  2e:	0000                	unimp
  30:	0160                	addi	s0,sp,140
  32:	0000                	unimp
  34:	0000                	unimp
  36:	0000                	unimp
  38:	0160                	addi	s0,sp,140
  3a:	0000                	unimp
  3c:	0000                	unimp
  3e:	0000                	unimp
  40:	0160                	addi	s0,sp,140
  42:	0000                	unimp
  44:	0160                	addi	s0,sp,140
  46:	0000                	unimp
  48:	0160                	addi	s0,sp,140
  4a:	0000                	unimp
  4c:	0160                	addi	s0,sp,140
  4e:	0000                	unimp
  50:	0160                	addi	s0,sp,140
  52:	0000                	unimp
  54:	0160                	addi	s0,sp,140
  56:	0000                	unimp
  58:	0160                	addi	s0,sp,140
  5a:	0000                	unimp
  5c:	0000                	unimp
  5e:	0000                	unimp
  60:	0160                	addi	s0,sp,140
  62:	0000                	unimp
  64:	0160                	addi	s0,sp,140
  66:	0000                	unimp
  68:	0160                	addi	s0,sp,140
  6a:	0000                	unimp
  6c:	0160                	addi	s0,sp,140
  6e:	0000                	unimp
  70:	0160                	addi	s0,sp,140
  72:	0000                	unimp
  74:	0160                	addi	s0,sp,140
  76:	0000                	unimp
  78:	0160                	addi	s0,sp,140
  7a:	0000                	unimp
  7c:	0160                	addi	s0,sp,140
  7e:	0000                	unimp
  80:	0160                	addi	s0,sp,140
  82:	0000                	unimp
  84:	0160                	addi	s0,sp,140
  86:	0000                	unimp
  88:	0160                	addi	s0,sp,140
  8a:	0000                	unimp
  8c:	0160                	addi	s0,sp,140
	...

Disassembly of section .text:

00000090 <DelaySysTick>:
{
#if defined(CH32V003) || defined(CH32V00x)
	uint32_t targend = SysTick->CNT + n;
	while( ((int32_t)( SysTick->CNT - targend )) < 0 );
#elif defined(CH32V20x) || defined(CH32V30x) || defined(CH32X03x) || defined(CH32L103) || defined(CH582_CH583) || defined(CH591_CH592) || defined(CH32H41x)
	uint64_t targend = SysTick->CNT + n;
  90:	e000f7b7          	lui	a5,0xe000f
  94:	4798                	lw	a4,8(a5)
  96:	47dc                	lw	a5,12(a5)
	while( ((int64_t)( SysTick->CNT - targend )) < 0 );
  98:	e000f837          	lui	a6,0xe000f
	uint64_t targend = SysTick->CNT + n;
  9c:	00e505b3          	add	a1,a0,a4
  a0:	00a5b533          	sltu	a0,a1,a0
  a4:	953e                	add	a0,a0,a5
	while( ((int64_t)( SysTick->CNT - targend )) < 0 );
  a6:	00882603          	lw	a2,8(a6) # e000f008 <_eusrstack+0xc0007008>
  aa:	00c82683          	lw	a3,12(a6)
  ae:	40b607b3          	sub	a5,a2,a1
  b2:	00f63733          	sltu	a4,a2,a5
  b6:	40a687b3          	sub	a5,a3,a0
  ba:	8f99                	sub	a5,a5,a4
  bc:	fe07c5e3          	bltz	a5,a6 <DelaySysTick+0x16>
	uint64_t targend = SysTick->CNT - n;
	while( ((int64_t)( SysTick->CNT - targend )) > 0 );
#else
	#error DelaySysTick not defined.
#endif
}
  c0:	8082                	ret

000000c2 <handle_reset>:
	asm volatile( "\n\
  c2:	20000197          	auipc	gp,0x20000
  c6:	33a18193          	addi	gp,gp,826 # 200003fc <__global_pointer$>
  ca:	20008117          	auipc	sp,0x20008
  ce:	f3610113          	addi	sp,sp,-202 # 20008000 <_eusrstack>
	asm volatile(
  d2:	c0418513          	addi	a0,gp,-1020 # 20000000 <_data_vma>
  d6:	c0418593          	addi	a1,gp,-1020 # 20000000 <_data_vma>
  da:	00b57763          	bgeu	a0,a1,e8 <handle_reset+0x26>
  de:	00052023          	sw	zero,0(a0)
  e2:	0511                	addi	a0,a0,4
  e4:	feb56de3          	bltu	a0,a1,de <handle_reset+0x1c>
  e8:	09000513          	li	a0,144
  ec:	c0418593          	addi	a1,gp,-1020 # 20000000 <_data_vma>
  f0:	c0418613          	addi	a2,gp,-1020 # 20000000 <_data_vma>
  f4:	00c5fa63          	bgeu	a1,a2,108 <handle_reset+0x46>
  f8:	00052283          	lw	t0,0(a0)
  fc:	0055a023          	sw	t0,0(a1)
 100:	0511                	addi	a0,a0,4
 102:	0591                	addi	a1,a1,4
 104:	fec5eae3          	bltu	a1,a2,f8 <handle_reset+0x36>
 108:	31800513          	li	a0,792
 10c:	c0418593          	addi	a1,gp,-1020 # 20000000 <_data_vma>
 110:	c0418613          	addi	a2,gp,-1020 # 20000000 <_data_vma>
 114:	00c58a63          	beq	a1,a2,128 <handle_reset+0x66>
 118:	00052283          	lw	t0,0(a0)
 11c:	0055a023          	sw	t0,0(a1)
 120:	0511                	addi	a0,a0,4
 122:	0591                	addi	a1,a1,4
 124:	fec5eae3          	bltu	a1,a2,118 <handle_reset+0x56>
	asm volatile(
 128:	00000793          	li	a5,0
 12c:	42fd                	li	t0,31
 12e:	bc029073          	csrw	0xbc0,t0
 132:	6289                	lui	t0,0x2
 134:	88828293          	addi	t0,t0,-1912 # 1888 <ch32fun.c.a95072fe+0x87d>
 138:	3002a073          	csrs	mstatus,t0
 13c:	00000297          	auipc	t0,0x0
 140:	ec428293          	addi	t0,t0,-316 # 0 <InterruptVector>
 144:	0032e293          	ori	t0,t0,3
 148:	30529073          	csrw	mtvec,t0
	SysTick->CTLR = 1;
 14c:	e000f7b7          	lui	a5,0xe000f
 150:	4705                	li	a4,1
 152:	c398                	sw	a4,0(a5)
	asm volatile(
 154:	20a00793          	li	a5,522
 158:	34179073          	csrw	mepc,a5
 15c:	30200073          	mret

00000160 <ADC1_2_IRQHandler>:
	asm volatile( "1: j 1b" );
 160:	a001                	j	160 <ADC1_2_IRQHandler>

00000162 <SystemInit>:
#endif
		);
	}
#else // ch5xx EXCEPT ch570/2 ch584/5
	SYS_CLKTypeDef sc = CLK_SOURCE_CH5XX;
	SYS_SAFE_ACCESS(
 162:	400017b7          	lui	a5,0x40001
 166:	05700693          	li	a3,87
 16a:	04d78023          	sb	a3,64(a5) # 40001040 <_eusrstack+0x1fff9040>
 16e:	fa800713          	li	a4,-88
 172:	04e78023          	sb	a4,64(a5)
 176:	0001                	nop
 178:	0001                	nop
 17a:	04b7c603          	lbu	a2,75(a5)
 17e:	0df67613          	andi	a2,a2,223
 182:	04c785a3          	sb	a2,75(a5)
 186:	04078023          	sb	zero,64(a5)
 18a:	0001                	nop
 18c:	0001                	nop
			R8_FLASH_CFG = 0x51;
		);
	}
	else if(sc & 0x40) // PLL div
	{
		SYS_SAFE_ACCESS(
 18e:	04d78023          	sb	a3,64(a5)
 192:	04e78023          	sb	a4,64(a5)
 196:	0001                	nop
 198:	0001                	nop
 19a:	00140637          	lui	a2,0x140
 19e:	04860613          	addi	a2,a2,72 # 140048 <pwm_basic.c.7ee8aa68+0x13e129>
 1a2:	c790                	sw	a2,8(a5)
 1a4:	04078023          	sb	zero,64(a5)
 1a8:	0001                	nop
 1aa:	0001                	nop
			R32_CLK_SYS_CFG = (1 << 6) | (sc & 0x1f) | RB_TX_32M_PWR_EN | RB_PLL_PWR_EN;
		);
		ADD_N_NOPS(4);
 1ac:	0001                	nop
 1ae:	0001                	nop
 1b0:	0001                	nop
 1b2:	0001                	nop
		SYS_SAFE_ACCESS(
 1b4:	04d78023          	sb	a3,64(a5)
 1b8:	04e78023          	sb	a4,64(a5)
 1bc:	0001                	nop
 1be:	0001                	nop
 1c0:	40002637          	lui	a2,0x40002
 1c4:	05200593          	li	a1,82
 1c8:	80b603a3          	sb	a1,-2041(a2) # 40001807 <_eusrstack+0x1fff9807>
 1cc:	04078023          	sb	zero,64(a5)
 1d0:	0001                	nop
 1d2:	0001                	nop
		SYS_SAFE_ACCESS(
			R32_CLK_SYS_CFG |= RB_CLK_SYS_MOD;
		);
	}

	SYS_SAFE_ACCESS(
 1d4:	04d78023          	sb	a3,64(a5)
 1d8:	04e78023          	sb	a4,64(a5)
 1dc:	0001                	nop
 1de:	0001                	nop
 1e0:	04b7c703          	lbu	a4,75(a5)
 1e4:	f8076713          	ori	a4,a4,-128
 1e8:	0ff77713          	andi	a4,a4,255
 1ec:	04e785a3          	sb	a4,75(a5)
 1f0:	04078023          	sb	zero,64(a5)
 1f4:	0001                	nop
 1f6:	0001                	nop
	*DMDATA1 = 0x00;
 1f8:	e00007b7          	lui	a5,0xe0000
 1fc:	3807a223          	sw	zero,900(a5) # e0000384 <_eusrstack+0xbfff8384>
	*DMDATA0 = 0x80;
 200:	08000713          	li	a4,128
 204:	38e7a023          	sw	a4,896(a5)
	SetupDebugPrintf();
#endif
#if defined(FUNCONF_SUPPORT_CONSTRUCTORS) && FUNCONF_SUPPORT_CONSTRUCTORS
	CallConstructors();
#endif
}
 208:	8082                	ret

0000020a <main>:
#include "ch32fun.h"
#include "fun_pwm_ch5xx.h"

u8 adc_channel = 4;		// PA12

int main() {
 20a:	7179                	addi	sp,sp,-48
 20c:	d606                	sw	ra,44(sp)
 20e:	d422                	sw	s0,40(sp)
 210:	d226                	sw	s1,36(sp)
 212:	d04a                	sw	s2,32(sp)
 214:	ce4e                	sw	s3,28(sp)
 216:	cc52                	sw	s4,24(sp)
 218:	ca56                	sw	s5,20(sp)
 21a:	c85a                	sw	s6,16(sp)
 21c:	c65e                	sw	s7,12(sp)
	SystemInit();
 21e:	3791                	jal	162 <SystemInit>
	Delay_Ms(100);
 220:	000b7537          	lui	a0,0xb7
 224:	1b050513          	addi	a0,a0,432 # b71b0 <pwm_basic.c.7ee8aa68+0xb5291>
 228:	35a5                	jal	90 <DelaySysTick>
    R8_PWM_OUT_EN |= (1 << (channel - 4));
}

void pwm_config(u8 bit_width, u8 cycle_sel) {
    // Clear the configuration bits first, then set new values
    R8_PWM_CONFIG &= ~(RB_PWM_CYC_MOD | RB_PWM_CYCLE_SEL);
 22a:	400057b7          	lui	a5,0x40005
 22e:	0027c703          	lbu	a4,2(a5) # 40005002 <_eusrstack+0x1fffd002>
	case GPIO_ModeOut_PP_5mA:
		*(&R32_PA_PD_DRV + OFFSET_FOR_GPIOB(pin)) &= ~(pin & ~PB);
		*(&R32_PA_DIR + OFFSET_FOR_GPIOB(pin))    |= (pin & ~PB);
		break;
	case GPIO_ModeOut_PP_20mA:
		*(&R32_PA_PD_DRV + OFFSET_FOR_GPIOB(pin)) |= (pin & ~PB);
 232:	6585                	lui	a1,0x1
	u8 percent = 0;

	while(1) {
		pwm_set_duty_cycle(adc_channel, percent);
		if (++percent > 100) percent = 0;
		Delay_Ms(15);
 234:	64ed                	lui	s1,0x1b
 236:	0f277713          	andi	a4,a4,242
 23a:	00e78123          	sb	a4,2(a5)
            bit_width_value = 0;       // 00 in bits [3:2] = 0x00
            break;
    }
    
    // Set the configuration
    R8_PWM_CONFIG |= bit_width_value;
 23e:	0027c703          	lbu	a4,2(a5)
	u8 percent = 0;
 242:	4401                	li	s0,0
 244:	06400913          	li	s2,100
 248:	0ff77713          	andi	a4,a4,255
 24c:	00e78123          	sb	a4,2(a5)
    if (cycle_sel) {
        R8_PWM_CONFIG |= RB_PWM_CYCLE_SEL;
 250:	0027c703          	lbu	a4,2(a5)
    // Clamp duty cycle to valid range
    if (duty_cycle_percent > 100) duty_cycle_percent = 100;

	// Ncyc = cycle_sel ? (2^n-1) : (2^n) 
	// (n= data bit width), the Ncyc result ranges from 63 to 256. 
    u8 config = R8_PWM_CONFIG;
 254:	400059b7          	lui	s3,0x40005
    u8 width_bits = (config & RB_PWM_CYC_MOD) >> 2;  // Extract bits [3:2]
    u8 cycle_sel = config & RB_PWM_CYCLE_SEL;

    // Calculate Ncyc based on current configuration
    u16 ncyc;
    switch(width_bits) {
 258:	4a09                	li	s4,2
        R8_PWM_CONFIG |= RB_PWM_CYCLE_SEL;
 25a:	0ff77713          	andi	a4,a4,255
 25e:	00176713          	ori	a4,a4,1
 262:	00e78123          	sb	a4,2(a5)
 266:	40001737          	lui	a4,0x40001
 26a:	08070713          	addi	a4,a4,128 # 40001080 <_eusrstack+0x1fff9080>
 26e:	5b50                	lw	a2,52(a4)
        case 0: ncyc = cycle_sel ? 255 : 256; break; // 8-bit: 00
        case 1: ncyc = cycle_sel ? 127 : 128; break; // 7-bit: 01  
        case 2: ncyc = cycle_sel ? 63 : 64; break;   // 6-bit: 10
 270:	04000a93          	li	s5,64
    switch(width_bits) {
 274:	4b0d                	li	s6,3
 276:	8e4d                	or	a2,a2,a1
 278:	db50                	sw	a2,52(a4)
		*(&R32_PA_DIR + OFFSET_FOR_GPIOB(pin))    |= (pin & ~PB);
 27a:	5314                	lw	a3,32(a4)
        case 3: ncyc = cycle_sel ? 31 : 32; break;   // 5-bit: 11
 27c:	02000b93          	li	s7,32
		Delay_Ms(15);
 280:	77448493          	addi	s1,s1,1908 # 1b774 <pwm_basic.c.7ee8aa68+0x19855>
 284:	8ecd                	or	a3,a3,a1
 286:	d314                	sw	a3,32(a4)
    (polarity) ? (R8_PWM_POLAR |= polarity_bit) : (R8_PWM_POLAR &= ~polarity_bit);
 288:	0017c703          	lbu	a4,1(a5)
 28c:	0fe77713          	andi	a4,a4,254
 290:	00e780a3          	sb	a4,1(a5)
	R8_PWM_CLOCK_DIV = clock_divider;
 294:	4711                	li	a4,4
 296:	00e781a3          	sb	a4,3(a5)
    R8_PWM_OUT_EN |= (1 << (channel - 4));
 29a:	0007c703          	lbu	a4,0(a5)
 29e:	0ff77713          	andi	a4,a4,255
 2a2:	00176713          	ori	a4,a4,1
 2a6:	00e78023          	sb	a4,0(a5)
    if (duty_cycle_percent > 100) duty_cycle_percent = 100;
 2aa:	87a2                	mv	a5,s0
 2ac:	00897463          	bgeu	s2,s0,2b4 <main+0xaa>
 2b0:	06400793          	li	a5,100
 2b4:	0ff7f713          	andi	a4,a5,255
    u8 config = R8_PWM_CONFIG;
 2b8:	0029c783          	lbu	a5,2(s3) # 40005002 <_eusrstack+0x1fffd002>
 2bc:	0ff7f793          	andi	a5,a5,255
    u8 width_bits = (config & RB_PWM_CYC_MOD) >> 2;  // Extract bits [3:2]
 2c0:	4027d693          	srai	a3,a5,0x2
 2c4:	8a8d                	andi	a3,a3,3
    u8 cycle_sel = config & RB_PWM_CYCLE_SEL;
 2c6:	8b85                	andi	a5,a5,1
    switch(width_bits) {
 2c8:	05468163          	beq	a3,s4,30a <main+0x100>
 2cc:	05668263          	beq	a3,s6,310 <main+0x106>
 2d0:	4605                	li	a2,1
 2d2:	02c68963          	beq	a3,a2,304 <main+0xfa>
        case 0: ncyc = cycle_sel ? 255 : 256; break; // 8-bit: 00
 2d6:	10000693          	li	a3,256
        case 1: ncyc = cycle_sel ? 127 : 128; break; // 7-bit: 01  
 2da:	40f687b3          	sub	a5,a3,a5
        case 3: ncyc = cycle_sel ? 31 : 32; break;   // 5-bit: 11
 2de:	07c2                	slli	a5,a5,0x10
 2e0:	83c1                	srli	a5,a5,0x10
    }

    // Calculate PWM data value and write to register
	// Duty_cycle = (R8_PWMx_DATA / Ncyc) * 100%
	// R8_PWMx_DATA = (Duty_cycle * Ncyc) / 100
    u16 pwm_data = (u16)(duty_cycle_percent * ncyc / 100);
 2e2:	02f707b3          	mul	a5,a4,a5
		if (++percent > 100) percent = 0;
 2e6:	0405                	addi	s0,s0,1
 2e8:	0ff47413          	andi	s0,s0,255
 2ec:	0327c7b3          	div	a5,a5,s2

    switch (channel) {
        case 4: R8_PWM4_DATA = pwm_data; break;
 2f0:	0ff7f793          	andi	a5,a5,255
 2f4:	00f98223          	sb	a5,4(s3)
 2f8:	00897363          	bgeu	s2,s0,2fe <main+0xf4>
 2fc:	4401                	li	s0,0
		Delay_Ms(15);
 2fe:	8526                	mv	a0,s1
 300:	3b41                	jal	90 <DelaySysTick>
	while(1) {
 302:	b765                	j	2aa <main+0xa0>
        case 1: ncyc = cycle_sel ? 127 : 128; break; // 7-bit: 01  
 304:	08000693          	li	a3,128
 308:	bfc9                	j	2da <main+0xd0>
        case 2: ncyc = cycle_sel ? 63 : 64; break;   // 6-bit: 10
 30a:	40fa87b3          	sub	a5,s5,a5
 30e:	bfc1                	j	2de <main+0xd4>
        case 3: ncyc = cycle_sel ? 31 : 32; break;   // 5-bit: 11
 310:	40fb87b3          	sub	a5,s7,a5
 314:	b7e9                	j	2de <main+0xd4>
	...
